<?php

namespace App\Listeners;

use App\Events\AppointmentRescheduled;
use App\Events\NotificationCreated;
use App\Notifications\AppointmentRescheduledNotification;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class HandleAppointmentRescheduled
{
    /**
     * Create the event listener.
     */
    public function __construct()
    {
        //
    }

    /**
     * Handle the event.
     */
    public function handle(AppointmentRescheduled $event): void
    {
        $appointment = $event->appointment;
        $oldDateTime = $event->oldDateTime;
        $newDateTime = $event->newDateTime;
        
        // Crear una clave √∫nica para este reagendamiento espec√≠fico
        $rescheduleKey = "appointment_rescheduled_{$appointment->id}_{$oldDateTime}_{$newDateTime}";
        
        // Verificar si ya se proces√≥ este reagendamiento en los √∫ltimos 5 segundos
        if (\Illuminate\Support\Facades\Cache::has($rescheduleKey)) {
            Log::info("üö´ Reagendamiento ya procesado, evitando duplicado para appointment {$appointment->id}");
            return;
        }
        
        // Marcar como procesado por 5 segundos
        \Illuminate\Support\Facades\Cache::put($rescheduleKey, true, 5);
        
        // Cargar las relaciones necesarias
        $appointment->load(['technical', 'ticket.user']);

        if (!$appointment->technical || !$appointment->ticket || !$appointment->ticket->user) {
            Log::warning("Missing technical or member for rescheduled appointment {$appointment->id}");
            return;
        }

        // Obtener el usuario correspondiente al t√©cnico por email
        $technicalUser = \App\Models\User::where('email', $appointment->technical->email)->first();
        if (!$technicalUser) {
            Log::warning("No user found for technical email: {$appointment->technical->email}");
            return;
        }

        Log::info("üìÖ Appointment rescheduled - sending notifications and scheduling new reminders for appointment {$appointment->id}");
        Log::info("üîÑ Rescheduled from {$oldDateTime} to {$newDateTime}");

        // 1. Crear y enviar notificaci√≥n de reagendamiento al t√©cnico
        $technicalUser->notify(new AppointmentRescheduledNotification($appointment, $oldDateTime, $newDateTime, 'technical'));
        Log::info("üìß Technical notification saved to database for user {$technicalUser->id}");
        
        // Emit real-time notification event for technical
        $technicalDatabaseNotification = $technicalUser->notifications()->latest()->first();
        if ($technicalDatabaseNotification) {
            event(new NotificationCreated($technicalDatabaseNotification, $technicalUser->id));
            Log::info("ÔøΩ Technical notification broadcasted for user {$technicalUser->id}");
        }

        // 2. Crear y enviar notificaci√≥n de reagendamiento al cliente
        $appointment->ticket->user->notify(new AppointmentRescheduledNotification($appointment, $oldDateTime, $newDateTime, 'member'));
        Log::info("üìß Member notification saved to database for user {$appointment->ticket->user->id}");
        
        // Emit real-time notification event for member
        $memberDatabaseNotification = $appointment->ticket->user->notifications()->latest()->first();
        if ($memberDatabaseNotification) {
            event(new NotificationCreated($memberDatabaseNotification, $appointment->ticket->user->id));
            Log::info("üì° Member notification broadcasted for user {$appointment->ticket->user->id}");
        }

        // 4. Programar nuevos recordatorios para la nueva hora (solo broadcasting de recordatorios)
        // TEMPORALMENTE DESHABILITADO PARA DEBUG
        // $this->scheduleNewReminders($appointment, $newDateTime, $technicalUser);
    }

    /**
     * Schedule new appointment reminders
     */
    protected function scheduleNewReminders($appointment, $newDateTime, $technicalUser)
    {
        $appointmentTime = Carbon::parse($newDateTime);
        $now = Carbon::now();
        
        // Solo programar recordatorios si la nueva cita est√° en el futuro
        if ($appointmentTime->gt($now)) {
            $reminderIntervals = [30, 15, 10, 5, 1];

            // Enviar recordatorios inmediatos para cada intervalo
            foreach ($reminderIntervals as $minutes) {
                $reminderTime = $appointmentTime->copy()->subMinutes($minutes);
                
                // Solo enviar recordatorios que a√∫n no han pasado
                if ($reminderTime->gt($now)) {
                    $timeText = $minutes === 0 ? 'ahora' : "en {$minutes} minutos";
                    $urgency = $minutes <= 2 ? 'high' : 'medium';

                    // Notificaci√≥n al t√©cnico
                    broadcast(new NotificationCreated([
                        'type' => 'appointment_reminder',
                        'title' => 'üîî Recordatorio de Cita Reagendada',
                        'message' => "Tu cita reagendada como t√©cnico iniciar√° {$timeText}: {$appointment->title}",
                        'data' => [
                            'appointment_id' => $appointment->id,
                            'minutes_before' => $minutes,
                            'urgency' => $urgency,
                            'appointment_title' => $appointment->title,
                            'appointment_address' => $appointment->address,
                            'ticket_code' => $appointment->ticket->code,
                            'scheduled_for' => $newDateTime,
                            'reminder_time' => $reminderTime->toISOString(),
                            'is_rescheduled' => true,
                        ],
                    ], $technicalUser->id));

                    // Notificaci√≥n al cliente
                    broadcast(new NotificationCreated([
                        'type' => 'appointment_reminder',
                        'title' => 'üîî Recordatorio de Cita Reagendada',
                        'message' => "Tu cita reagendada como cliente iniciar√° {$timeText}: {$appointment->title}",
                        'data' => [
                            'appointment_id' => $appointment->id,
                            'minutes_before' => $minutes,
                            'urgency' => $urgency,
                            'appointment_title' => $appointment->title,
                            'appointment_address' => $appointment->address,
                            'ticket_code' => $appointment->ticket->code,
                            'scheduled_for' => $newDateTime,
                            'reminder_time' => $reminderTime->toISOString(),
                            'is_rescheduled' => true,
                        ],
                    ], $appointment->ticket->user->id));

                    Log::info("ÔøΩ Sent rescheduled reminder for {$minutes} minutes before appointment {$appointment->id}");
                } else {
                    Log::info("ÔøΩ Skipped rescheduled reminder for {$minutes} minutes before appointment {$appointment->id} (time already passed)");
                }
            }

            Log::info("üì± All rescheduled appointment reminders sent for both technical #{$technicalUser->id} and member #{$appointment->ticket->user->id}");
        } else {
            Log::info("‚è∞ Rescheduled appointment is in the past, no reminders scheduled");
        }
    }
}
