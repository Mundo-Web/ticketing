# üì± API de Notificaciones para App M√≥vil

## üéØ Objetivo
Esta documentaci√≥n explica c√≥mo la app m√≥vil puede obtener y mostrar notificaciones del sistema de tickets tanto como **push notifications** como **modales dentro de la app**.

## üîÑ Flujo General de Notificaciones

```mermaid
graph TD
    A[Usuario hace acci√≥n] --> B[NotificationDispatcherService]
    B --> C[Guarda notificaci√≥n en DB]
    C --> D[Env√≠a PUSH a m√≥vil]
    D --> E[üì± App recibe push]
    E --> F[App puede mostrar modal]
    F --> G[Usar API para obtener datos completos]
```

---

## üì° **API Endpoints Disponibles**

### **1. üîî Obtener Notificaciones**
```http
GET /api/tenant/notifications
Authorization: Bearer {token}
```

**‚ö†Ô∏è Importante:** 
- Retorna las **50 notificaciones m√°s recientes** (no todas)
- Ordenadas por fecha descendente (m√°s nuevas primero)
- Para obtener m√°s notificaciones, implementar paginaci√≥n (ver abajo)

**Par√°metros opcionales:**
- `?limit=20` - Limitar cantidad (m√°ximo 50)
- `?unread_only=true` - Solo no le√≠das

**Respuesta:**
```json
{
  "success": true,
  "notifications": [
    {
      "id": "uuid-notification-id",
      "type": "App\\Notifications\\TicketNotification",
      "title": "üë®‚Äçüîß Ticket Assigned",
      "message": "The ticket 'Problema con aire acondicionado' has been assigned to John Doe (Phone: +1234567890) - Device: Samsung Aire Acondicionado Sala at Apto 301, Edificio Central",
      
      // üé´ TICKET DATA (campos directos como en push notifications)
      "ticket_id": 123,
      "ticket_code": "TCK-00123",
      "ticket_title": "Problema con aire acondicionado",
      "ticket_status": "assigned",
      "ticket_priority": "high",
      
      // üîß DEVICE DATA (campos directos, incluye imagen nueva)
      "device_id": 456,
      "device_name": "Aire Acondicionado Sala",
      "device_image": "/storage/name_devices/ac_image.jpg", // ‚úÖ NUEVA IMAGEN
      "device_icon": 1,
      "device_brand": "Samsung",
      "device_model": "WindFree",
      "device_ubicacion": "Sala Principal",
      
      // üë®‚Äçüíª TECHNICAL DATA (campos directos)
      "technical_id": 789,
      "technical_name": "John Doe",
      "technical_phone": "+1234567890",
      "technical_photo": "/storage/technicals/john_photo.jpg",
      
      // üè† LOCATION DATA (campos directos)
      "client_name": "Mar√≠a Garc√≠a",
      "client_phone": "+0987654321",
      "building_name": "Edificio Central",
      "apartment_name": "Apto 301",
      
      // üìä STATUS CHANGE DATA (solo para cambios de estado)
      "old_status": "open",
      "new_status": "assigned",
      "changed_by": "Admin User",
      
      // üé® UI DATA
      "priority": "high",
      "notification_type": "ticket_assigned", // Ver tipos abajo
      "icon": "bell",
      "color": "blue",
      
      // üìÖ META DATA
      "is_read": false,
      "read_at": null,
      "created_at": "2025-09-28T10:30:00.000Z",
      "updated_at": "2025-09-28T10:30:00.000Z"
    }
  ],
  "unread_count": 3,
  "total_count": 15
}
```

### **2. ‚úÖ Marcar Notificaci√≥n como Le√≠da**
```http
POST /api/tenant/notifications/{notification_id}/read
Authorization: Bearer {token}
```

### **3. ‚úÖ Marcar Todas como Le√≠das**
```http
POST /api/tenant/notifications/mark-all-read
Authorization: Bearer {token}
```

### **4. üìÑ Paginaci√≥n (Para implementar si necesitas m√°s de 50)**
```http
GET /api/tenant/notifications?offset=50&limit=25
Authorization: Bearer {token}
```

**Nota:** La paginaci√≥n no est√° implementada actualmente. Si necesitas m√°s de 50 notificaciones, contacta al backend para implementar paginaci√≥n.

---

## üí° **Mejores Pr√°cticas para la App**

### **üéØ Para Modales en Tiempo Real:**
1. **Usar polling cada 30-60 segundos** para verificar notificaciones nuevas
2. **Filtrar por timestamp** - Solo mostrar modal si la notificaci√≥n es de los √∫ltimos 2-5 minutos
3. **Evitar spam** - No mostrar modal si ya hay uno abierto

### **üì± Para Lista de Notificaciones:**
1. **Cache local** - Guardar las 50 notificaciones en el dispositivo
2. **Pull to refresh** - Actualizar al hacer swipe down
3. **Marcar como le√≠da** al abrir el modal o navegar al ticket

```javascript
// Ejemplo de implementaci√≥n √≥ptima
class NotificationManager {
    constructor() {
        this.lastCheck = null;
        this.modalOpen = false;
    }
    
    async checkForNewNotifications() {
        const notifications = await fetchNotifications();
        
        // Solo notificaciones de los √∫ltimos 2 minutos
        const veryRecent = notifications.filter(n => 
            !n.is_read && 
            isWithinLastMinutes(n.created_at, 2)
        );
        
        // No mostrar modal si ya hay uno abierto
        if (veryRecent.length > 0 && !this.modalOpen) {
            this.showModal(veryRecent[0]);
        }
    }
    
    showModal(notification) {
        this.modalOpen = true;
        // ... mostrar modal
    }
    
    dismissModal() {
        this.modalOpen = false;
    }
}
```

---

## üîî **Tipos de Notificaciones**

| Tipo | `notification_type` | Cu√°ndo ocurre | Datos especiales |
|------|-------------------|---------------|------------------|
| **Ticket Asignado** | `ticket_assigned` | Se asigna t√©cnico | `technical_*` fields |
| **Cambio de Estado** | `ticket_status_changed` | Status cambia | `old_status`, `new_status` |
| **Ticket Creado** | `ticket_created` | Nuevo ticket | `created_by` |
| **Comentario Agregado** | `ticket_comment` | Nuevo comentario | `comment`, `comment_by` |
| **Cita Creada** | `appointment_created` | Nueva cita | `appointment_*` fields |
| **Cita Iniciada** | `appointment_started` | Cita comienza | `appointment_*` fields |
| **Cita Completada** | `appointment_completed` | Cita termina | `completion_notes` |
| **Ticket Resuelto** | `ticket_resolved` | Ticket resuelto | `technical_photo` |

---

## üé® **Implementaci√≥n en la App M√≥vil**

### **ÔøΩ Problema: Push Notifications solo funcionan cuando la app est√° cerrada**

‚ùå **Push Notifications**: Solo llegan cuando la app est√° en background/cerrada  
‚úÖ **Soluci√≥n**: Combinar push + polling/WebSocket para app abierta

### **1. üì± Estrategia H√≠brida: Push + Polling**

```javascript
// services/NotificationService.js
class NotificationService {
    constructor(apiService) {
        this.apiService = apiService;
        this.isAppActive = true;
        this.lastNotificationCheck = null;
        this.pollingInterval = null;
        this.modalOpen = false;
    }
    
    // üîî Setup completo para app abierta Y cerrada
    setupNotifications() {
        // 1. Push notifications para app cerrada/background
        this.setupPushNotifications();
        
        // 2. Polling para app abierta
        this.startPollingWhenAppActive();
        
        // 3. Detectar cuando app cambia de estado
        this.setupAppStateListener();
    }
    
    // ÔøΩ Polling para cuando la app est√° ABIERTA
    startPollingWhenAppActive() {
        if (this.pollingInterval) return;
        
        this.pollingInterval = setInterval(async () => {
            if (this.isAppActive && !this.modalOpen) {
                await this.checkForNewNotifications();
            }
        }, 10000); // Cada 10 segundos cuando app est√° abierta
    }
    
    // üîç Verificar notificaciones nuevas
    async checkForNewNotifications() {
        try {
            const response = await this.apiService.get('/tenant/notifications?limit=5');
            const notifications = response.data.notifications;
            
            // Buscar notificaciones muy recientes (√∫ltimos 30 segundos)
            const veryRecent = notifications.filter(notification => {
                const notificationTime = new Date(notification.created_at);
                const now = new Date();
                const diffMs = now - notificationTime;
                
                // Solo √∫ltimos 30 segundos Y no le√≠das
                return diffMs <= 30000 && !notification.is_read;
            });
            
            if (veryRecent.length > 0) {
                const latestNotification = veryRecent[0];
                this.showModalFromAPIData(latestNotification);
            }
            
        } catch (error) {
            console.error('‚ùå Error checking notifications:', error);
        }
    }
    
    // üéØ Mostrar modal con datos de la API
    showModalFromAPIData(notification) {
        if (this.modalOpen) return;
        
        this.modalOpen = true;
        
        const modalData = {
            // Los datos est√°n disponibles directamente (no en objetos anidados)
            ticketId: notification.ticket_id,
            ticketCode: notification.ticket_code,
            ticketTitle: notification.ticket_title,
            
            // Device data (con nueva imagen) - campos directos
            deviceName: notification.device_name,
            deviceImage: notification.device_image, // ‚úÖ Nueva imagen disponible
            deviceBrand: notification.device_brand,
            deviceUbicacion: notification.device_ubicacion,
            
            // Technical data - campos directos
            technicalName: notification.technical_name,
            technicalPhone: notification.technical_phone,
            technicalPhoto: notification.technical_photo,
            
            // Client/Location data - campos directos
            clientName: notification.client_name,
            clientPhone: notification.client_phone,
            apartmentName: notification.apartment_name,
            buildingName: notification.building_name,
            
            // Notification data
            message: notification.message,
            notificationType: notification.notification_type,
            priority: notification.priority
        };
        
        // Mostrar modal espec√≠fico seg√∫n el tipo
        this.showModalByType(modalData);
        
        // Marcar como le√≠da autom√°ticamente
        this.markAsRead(notification.id);
    }
    
    // üì± Push notifications para app cerrada
    setupPushNotifications() {
        // Cuando la app se ABRE desde una push notification
        Notifications.addNotificationResponseReceivedListener(response => {
            console.log('üëÜ App opened from push notification');
            
            const pushData = response.notification.request.content.data;
            
            // Los datos del push vienen directamente en pushData (no objetos anidados)
            this.showModalFromPushData(pushData);
        });
    }
    
    // üîÑ Detectar estado de la app
    setupAppStateListener() {
        AppState.addEventListener('change', (nextAppState) => {
            this.isAppActive = nextAppState === 'active';
            
            console.log(`üì± App state: ${nextAppState}`);
            
            if (nextAppState === 'active') {
                // App volvi√≥ a primer plano - verificar notificaciones inmediatamente
                setTimeout(() => {
                    this.checkForNewNotifications();
                }, 1000);
            }
        });
    }
    
    // üé® Mostrar modal seg√∫n el tipo
    showModalByType(data) {
        switch (data.notificationType) {
            case 'ticket_assigned':
                this.showTicketAssignedModal(data);
                break;
            case 'ticket_status_changed':
                this.showStatusChangeModal(data);
                break;
            case 'appointment_created':
                this.showAppointmentModal(data);
                break;
            default:
                this.showGenericModal(data);
        }
    }
    
    showTicketAssignedModal(data) {
        Alert.alert(
            "‚úÖ T√©cnico Asignado",
            `${data.technicalName} fue asignado a "${data.ticketTitle}"`,
            [
                { 
                    text: "Ver Ticket", 
                    onPress: () => {
                        this.dismissModal();
                        this.navigateToTicket(data.ticketId);
                    }
                },
                {
                    text: "Llamar",
                    onPress: () => {
                        this.dismissModal();
                        this.callTechnical(data.technicalPhone);
                    }
                },
                { 
                    text: "Cerrar", 
                    style: "cancel",
                    onPress: () => this.dismissModal()
                }
            ]
        );
    }
    
    showStatusChangeModal(data) {
        Alert.alert(
            "üîÑ Estado Actualizado",
            `"${data.ticketTitle}" - Nuevo estado: ${data.newStatus}`,
            [
                { 
                    text: "Ver Ticket", 
                    onPress: () => {
                        this.dismissModal();
                        this.navigateToTicket(data.ticketId);
                    }
                },
                { 
                    text: "Cerrar", 
                    style: "cancel",
                    onPress: () => this.dismissModal()
                }
            ]
        );
    }
    
    dismissModal() {
        this.modalOpen = false;
    }
    
    // ‚úÖ Marcar como le√≠da
    async markAsRead(notificationId) {
        try {
            await this.apiService.post(`/tenant/notifications/${notificationId}/read`);
        } catch (error) {
            console.error('Error marking as read:', error);
        }
    }
    
    // üß≠ Navegaci√≥n
    navigateToTicket(ticketId) {
        // Tu l√≥gica de navegaci√≥n
        navigation.navigate('TicketDetail', { ticketId });
    }
    
    callTechnical(phone) {
        if (phone) {
            Linking.openURL(`tel:${phone}`);
        }
    }
    
    // üßπ Cleanup
    cleanup() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
        }
    }
}

// Singleton
export const notificationService = new NotificationService(apiService);
```

### **2. ÔøΩ Uso en la App**

```javascript
// App.js
import { notificationService } from './services/NotificationService';

export default function App() {
    useEffect(() => {
        // Inicializar servicio h√≠brido
        notificationService.setupNotifications();
        
        // Cleanup
        return () => {
            notificationService.cleanup();
        };
    }, []);

    return (
        <NavigationContainer>
            {/* Tu navegaci√≥n */}
        </NavigationContainer>
    );
}
```

### **2. üîî Polling para Nuevas Notificaciones**

```javascript
// Verificar cada 30 segundos si hay notificaciones nuevas
setInterval(async () => {
    const notifications = await fetchNotifications();
    const unreadRecent = notifications.filter(n => 
        !n.is_read && 
        isWithinLast5Minutes(n.created_at)
    );
    
    if (unreadRecent.length > 0) {
        showNotificationModal(unreadRecent[0]);
    }
}, 30000);

function isWithinLast5Minutes(timestamp) {
    const now = new Date();
    const notificationTime = new Date(timestamp);
    const diffMs = now - notificationTime;
    return diffMs <= 5 * 60 * 1000; // 5 minutos
}
```

### **3. üé® Ejemplos de Modales por Tipo**

#### **Modal para Ticket Asignado:**
```javascript
function showTicketAssignedModal(notification) {
    const modalData = {
        title: "T√©cnico Asignado ‚úÖ",
        message: `${notification.technical_name} fue asignado a tu ticket`,
        ticketCode: notification.ticket_code,
        ticketTitle: notification.ticket_title,
        deviceName: notification.device_name,
        deviceImage: notification.device_image, // ‚úÖ Usar nueva imagen
        technicalName: notification.technical_name,
        technicalPhoto: notification.technical_photo,
        technicalPhone: notification.technical_phone,
        priority: notification.priority,
        actions: [
            { text: "Ver Ticket", action: () => navigateToTicket(notification.ticket_id) },
            { text: "Contactar", action: () => callTechnical(notification.technical_phone) },
            { text: "Cerrar", action: () => dismissModal() }
        ]
    };
    
    showModal(modalData);
}
```

#### **Modal para Cambio de Estado:**
```javascript
function showStatusChangeModal(notification) {
    const statusEmojis = {
        'open': 'üîì',
        'assigned': 'üë®‚Äçüíª', 
        'in_progress': '‚ö°',
        'resolved': '‚úÖ',
        'closed': 'üîí'
    };
    
    const modalData = {
        title: `Estado Actualizado ${statusEmojis[notification.new_status]}`,
        message: `Tu ticket cambi√≥ de "${notification.old_status}" a "${notification.new_status}"`,
        ticketCode: notification.ticket_code,
        deviceName: notification.device_name,
        deviceImage: notification.device_image,
        changedBy: notification.changed_by,
        actions: [
            { text: "Ver Detalles", action: () => navigateToTicket(notification.ticket_id) },
            { text: "Cerrar", action: () => dismissModal() }
        ]
    };
    
    showModal(modalData);
}
```

---

## üöÄ **Estrategias de Implementaci√≥n**

### **‚úÖ Estrategia H√≠brida: Push + Polling (RECOMENDADO)**

#### **üì± App Cerrada/Background:**
- ‚úÖ **Push Notifications** funcionan perfectamente
- ‚úÖ Usuario recibe notificaci√≥n del sistema
- ‚úÖ Al abrir app ‚Üí mostrar modal con datos del push

#### **üì≤ App Abierta:**
- ‚ùå **Push Notifications NO LLEGAN** 
- ‚úÖ **Polling cada 10-30 segundos** a `/api/tenant/notifications`
- ‚úÖ Detectar notificaciones de √∫ltimos 30 segundos
- ‚úÖ Mostrar modal autom√°ticamente con datos de la API

#### **Flujo Completo:**
```
üì± App CERRADA ‚Üí Push llega ‚Üí Usuario abre app ‚Üí Modal con datos del push
üì± App ABIERTA ‚Üí Polling API ‚Üí Detecta nueva notificaci√≥n ‚Üí Modal con datos API
```

### **üîß Implementaci√≥n T√©cnica:**

```javascript
// Estrategia h√≠brida
class NotificationStrategy {
    setupHybridNotifications() {
        // 1. Para app cerrada/background
        this.setupPushNotifications();
        
        // 2. Para app abierta  
        this.startPolling();
        
        // 3. Detector de estado de app
        this.detectAppState();
    }
    
    setupPushNotifications() {
        // Solo funciona cuando app est√° cerrada
        Notifications.addNotificationResponseReceivedListener(response => {
            // Usuario toc√≥ la notificaci√≥n ‚Üí app se abre
            const pushData = response.notification.request.content.data;
            this.showModal(pushData); // Datos completos del push
        });
    }
    
    startPolling() {
        // Solo cuando app est√° abierta
        setInterval(async () => {
            if (this.isAppActive) {
                const notifications = await this.checkAPI();
                const recent = this.filterRecentNotifications(notifications);
                
                if (recent.length > 0) {
                    this.showModal(recent[0]); // Datos de la API
                }
            }
        }, 15000); // Cada 15 segundos
    }
}
```

---

### **‚ùå Estrategias NO Recomendadas:**

#### **Solo Push Notifications:**
- ‚ùå No funciona cuando app est√° abierta
- ‚ùå Usuario pierde notificaciones en tiempo real

#### **Solo Polling:**
- ‚ùå No funciona cuando app est√° cerrada
- ‚ùå Alto consumo de bater√≠a
- ‚ùå Retraso en las notificaciones

#### **WebSocket:**
- ‚úÖ Ser√≠a ideal para tiempo real
- ‚ùå Complejo de implementar
- ‚ùå Requiere cambios en el backend

---

## üîß **Datos Importantes**

### **URLs de Im√°genes:**
- **Device Images**: `https://tu-dominio.com/storage/{device_image}`
- **Technical Photos**: `https://tu-dominio.com/storage/{technical_photo}`
- **Building Photos**: `https://tu-dominio.com/storage/{building_photo}`

### **Estados de Ticket:**
- `open` - Abierto
- `assigned` - Asignado  
- `in_progress` - En progreso
- `resolved` - Resuelto
- `closed` - Cerrado
- `cancelled` - Cancelado

### **Prioridades:**
- `low` - Baja
- `medium` - Media
- `high` - Alta
- `urgent` - Urgente

---

## üìã **Checklist para el Desarrollador M√≥vil**

### **üéØ Implementaci√≥n Inmediata (Push ‚Üí Modal):**
- [ ] ‚úÖ **Ya tienes push notifications funcionando** (de los otros READMEs)
- [ ] ÔøΩ **Agregar listener de push** que muestre modal autom√°ticamente
- [ ] üé® **Crear modales espec√≠ficos** para cada `notification_type`
- [ ] üñºÔ∏è **Usar `device_image`** en los modales (nueva imagen del NameDevice)
- [ ] üìû **Botones de acci√≥n** (Ver Ticket, Llamar T√©cnico, etc.)
- [ ] üß™ **Testear con notificaciones reales** del backend

### **üîß Implementaci√≥n Opcional (APIs):**
- [ ] üì± Implementar fetch de lista de notificaciones (`/api/tenant/notifications`)
- [ ] ‚úÖ Implementar marcar como le√≠do
- [ ] üéØ Navegaci√≥n desde modal a pantalla espec√≠fica
- [ ] üé® Personalizar UI seg√∫n priority y type

---

## ‚ö° **Implementaci√≥n R√°pida - Solo lo Esencial**

Si quieres implementar **solo lo b√°sico** para que funcione inmediatamente:

```javascript
// 1Ô∏è‚É£ En tu PushNotificationService existente, agrega:
Notifications.addNotificationReceivedListener(notification => {
    const data = notification.request.content.data;
    
    // Modal b√°sico con datos del push (campos directos)
    Alert.alert(
        data.notification_type === 'ticket_assigned' ? '‚úÖ T√©cnico Asignado' : 'üîî Notificaci√≥n',
        data.body || data.message,
        [
            { text: 'Ver', onPress: () => navigateToTicket(data.ticket_id) },
            { text: 'Cerrar', style: 'cancel' }
        ]
    );
});

// 2Ô∏è‚É£ Para navegar al ticket:
function navigateToTicket(ticketId) {
    // Tu navegaci√≥n existente
    navigation.navigate('TicketDetail', { ticketId });
}
```

**üéâ ¬°Con esos 10 l√≠neas ya tienes modales autom√°ticos funcionando!**

### **üöÄ Implementaci√≥n Avanzada - Modal Completo**

Si quieres modales m√°s elaborados con toda la informaci√≥n:

```javascript
// Modal personalizado con toda la data del push (campos directos)
function showAdvancedModal(pushData) {
    const modalContent = (
        <View style={styles.modalContent}>
            {/* Imagen del device - campo directo */}
            {pushData.device_image && (
                <Image 
                    source={{ uri: `${API_BASE_URL}${pushData.device_image}` }}
                    style={styles.deviceImage}
                />
            )}
            
            {/* Info del ticket - campos directos */}
            <Text style={styles.title}>{pushData.ticket_title}</Text>
            <Text style={styles.code}>#{pushData.ticket_code}</Text>
            
            {/* Info del device - campos directos */}
            <Text style={styles.device}>
                üì± {pushData.device_name} ({pushData.device_brand})
            </Text>
            <Text style={styles.location}>
                üìç {pushData.device_ubicacion}
            </Text>
            
            {/* Info del t√©cnico - campos directos */}
            {pushData.technical_name && (
                <View style={styles.technicalInfo}>
                    <Text>üë®‚Äçüîß {pushData.technical_name}</Text>
                    {pushData.technical_phone && (
                        <Text>üìû {pushData.technical_phone}</Text>
                    )}
                </View>
            )}
            
            {/* Info de ubicaci√≥n - campos directos */}
            {pushData.apartment_name && pushData.building_name && (
                <Text style={styles.locationInfo}>
                    üè¢ {pushData.apartment_name}, {pushData.building_name}
                </Text>
            )}
            
            {/* Botones */}
            <View style={styles.actions}>
                <Button 
                    title="Ver Ticket" 
                    onPress={() => navigateToTicket(pushData.ticket_id)} 
                />
                {pushData.technical_phone && (
                    <Button 
                        title="Llamar" 
                        onPress={() => callTechnical(pushData.technical_phone)} 
                    />
                )}
            </View>
        </View>
    );
    
    // Mostrar tu modal personalizado
    showCustomModal(modalContent);
}
```

---

## üÜò **Soporte**

Para dudas sobre la API o datos faltantes, contacta al equipo backend. 

**Nota:** Todos los campos de `device_image` incluyen la nueva imagen del NameDevice que se agreg√≥ recientemente al sistema.

---

## üìã **Checklist para el Desarrollador M√≥vil**

### **üéØ Implementaci√≥n H√≠brida (Push + Polling):**
- [ ] ‚úÖ **Push notifications funcionando** para app cerrada (ya tienes esto)
- [ ] üîî **Polling cada 15-30 segundos** cuando app est√° abierta
- [ ] üéØ **Filtrar notificaciones recientes** (√∫ltimos 30 segundos)
- [ ] üé® **Modal autom√°tico** cuando detecta nuevas notificaciones  
- [ ] üì± **Detectar estado de app** (abierta vs cerrada)
- [ ] üñºÔ∏è **Usar `device_image`** en los modales (nueva imagen)
- [ ] ‚úÖ **Marcar como le√≠da** autom√°ticamente

### **üîß APIs Necesarias:**
- [ ] üì° `GET /api/tenant/notifications?limit=5` - Para polling
- [ ] ‚úÖ `POST /api/tenant/notifications/{id}/read` - Marcar como le√≠da

---

## ‚ö° **Implementaci√≥n R√°pida - H√≠brida**

### **1Ô∏è‚É£ Para App CERRADA (ya tienes esto):**
```javascript
// Push notifications - cuando usuario abre app desde notificaci√≥n
Notifications.addNotificationResponseReceivedListener(response => {
    const pushData = response.notification.request.content.data;
    showModalWithPushData(pushData);
});
```

### **2Ô∏è‚É£ Para App ABIERTA (nuevo):**
```javascript
// Polling cuando app est√° activa
const startNotificationPolling = () => {
    setInterval(async () => {
        if (AppState.currentState === 'active') {
            const response = await fetch('/api/tenant/notifications?limit=5');
            const data = await response.json();
            
            // Buscar notificaciones MUY recientes
            const recent = data.notifications.filter(n => {
                const diffMs = Date.now() - new Date(n.created_at).getTime();
                return diffMs <= 30000 && !n.is_read; // √öltimos 30 segundos
            });
            
            if (recent.length > 0) {
                showModalWithAPIData(recent[0]);
                markAsRead(recent[0].id);
            }
        }
    }, 15000); // Cada 15 segundos
};
```

### **3Ô∏è‚É£ Modal Universal:**
```javascript
function showModalWithAPIData(apiData) {
    Alert.alert(
        getModalTitle(apiData.notification_type),
        apiData.message,
        [
            { text: 'Ver', onPress: () => navigateToTicket(apiData.ticket_id) },
            { text: 'Cerrar', style: 'cancel' }
        ]
    );
}

function getModalTitle(type) {
    const titles = {
        'ticket_assigned': '‚úÖ T√©cnico Asignado',
        'ticket_status_changed': 'üîÑ Estado Actualizado',
        'appointment_created': 'üìÖ Nueva Cita'
    };
    return titles[type] || 'üîî Notificaci√≥n';
}
```

**üéâ ¬°Con esto tienes cobertura COMPLETA!**
- ‚úÖ App cerrada ‚Üí Push notifications  
- ‚úÖ App abierta ‚Üí Polling + modal autom√°tico